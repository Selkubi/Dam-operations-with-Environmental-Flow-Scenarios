---
title: "Translated Code"
output: html_document
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readr)
library(dplyr)
library(lubridate)
library(ggplot2)
library(plotly)
library(shiny)
```

First you need to download the whole folder containing the code (.R), the project (.Rproj) and the adiitonal information sheets. Once you have your local repository, you can first ofen the .Rproj file and then slect the Translation.R script from the *Files* tab. 

```{r}

```

### Read input flow record ####
The data is saved in q_tt and number of days the discharge is recorded is 731
```{r}
q_tt <- read_delim("Vermigliana_1996_1997.csv", delim=";", col_names = c("Date", "Monthly_flow"), col_types = "cd")
nq <- length(q_tt[["Monthly_flow"]]) #length of the flow record
head(nq)
```

Chose the eflow method that you want to apply by setting i_efty to;

* 1: constant for the whole year
* 2: for variable on monthly basis
* 3: for proportional input

```{r}
 i_efty <- 2


```

For the scenario to be applied, choose between 1-5;

* 1: VMF, 2014
* 2: Tessman, 1980
* 3: Smakhtin et al., 2004
* 4: Tennant, 1976
* 5: Q90-Q50, 2014

```{r}
i_mvef <- 1 
```
For the water consumption properties, chose 1 for consumptive, 0 for non-consumptive use
```{r}
icons <- 1 
```
Other parameters;

+ vrmax: max storage volume
+ vrmin: minimum storage volume
+ damhei: dam height (max available head)
+ power: power generated by the power plant
``` {r}
rvmax	<- 20 * 10^6 #(10^6m3) #to keep it line with Guido's notations
rvmin <- 1.5* 10^6 #(10^6m3)	
damhei <- 100 #(m)
power <- 0.1 * 10^6 #(MW)
```

### Pre-processing of inflows and downstream water uses ####
Here we organize the variables so that it's easier to use in the future. Now we have the day month and year as separate variables
```{r}
q_tt[["Date"]]<- mdy(q_tt[["Date"]])
q_tt <- q_tt%>%
  mutate(year= year(Date), 
         month=month(Date),
         day=day(Date))
```
 
 Then we calculate the monthly and yearly mean flow by grouping the observations by month or year. MMF_tt and MAF_tt has the mean flow of each month and year respectively.
 
``` {r message=F}
MMF_tt <- q_tt %>% group_by(year, month) %>%
  summarise(mean_monthly_flow=mean(Monthly_flow))

MAF_tt <- q_tt %>% group_by(year) %>%
  summarise(mean_yearly_flow=mean(Monthly_flow))

ny <- nrow(MAF_tt) # number of years in the dataset

MMF <- MMF_tt %>% group_by(month) %>%           # Mean monthly flow vector for the whole record
  summarise(month_average=mean(mean_monthly_flow))

MAF <- mean(MMF[["month_average"]])             # Mean annual flow

head(MMF_tt)
head(MMF)
```

50%, 90% and 97 % quantile calculation (there might be an error here but we kept it as Guido's)

```{r}
q50 <- q_tt %>% summarise(fifty_percentile = quantile(Monthly_flow, 0.50))
q90 <- q_tt %>% summarise(ninetth_percentile = quantile(Monthly_flow, 0.10))
q97 <- q_tt %>% summarise(ninetyseventh_percentile = quantile(Monthly_flow, 0.03))
```

### Eflow scenarios ####

``` {r}
qefm <-vector("numeric", 1)
LIHflo <- vector("numeric", 1)

if (i_efty==1){ #case 1:constant eflow throughout the whole year
  
  qefm <- rep(q90, 12)
 
   } else if (i_efty==2){ #case 2: variable eflow on a monthly basis
  
      if (i_mvef==1){                       # ----------------- VMF (2014)
        for (i in 1:nrow(MMF)) {
          if (MMF[i, 2] <= 0.4*MAF) {
            qefm[i] <- (0.6*MAF)
            LIHflo[i] <- 1    #i denotes a low flow month
            } else if(MMF[i, 2] > 0.4*MAF && MMF[i, 2] <= 0.8*MAF) {
              qefm[i] <- as.numeric(0.45*MMF[i, 2]) #SK:I added as.numeric() here, otherwise it produces a list of different classes. There might be a more efficient solution like structruing the lists from the begining, but for now this works ok. 
              LIHflo[i] <- 2    #i denotes an intermediate flow month
              } else {
                qefm[i] <-(0.3*MAF)
                LIHflo[i] <- 3 #i denotes a high flow month
              }
          }
        } 
     else if (i_mvef==2){                   # --------------- Tessmann (1980)
       for (i in 1:nrow(MMF)) {
        if (MMF[i, 2] <= 0.4*MAF) {
         qefm[i] <- as.numeric(MMF[i, 2]) #sk:see note above
         LIHflo[i] <- 1 #i denotes a low flow month
         } else if(MMF[i, 2] > 0.4*MAF && 0.4*MMF[i, 2] <= 0.4*MAF) {
           qefm[i] <- 0.4*MAF
           LIHflo[i] <- 2 #i denotes an intermediate flow month
           } else {
             qefm[i] <- 0.4*MAF
             LIHflo[i] <- 3 #i denotes a high flow month
      }
    } 
  } 
     else if (i_mvef==3) {                  #--------------- Smakhtin et al. (2004b)
       for (i in 1:nrow(MMF)) {
         if (MMF[i, 2] <= MAF) {
         qefm[i] <- q90[[1]] #sk:also for quantile data, instead of as.numeric, I just indicated the data to extract, need to test later on
         LIHflo[i] <- 1 #i denotes a low flow month
         } else {
           qefm[i] <- 0.2*MAF # check this rule
           LIHflo[i] <- 3 #i denotes a high flow month
      }
    } 
  } 
     else if (i_mvef==4) {                 #--------------- Tennant (1976)
      for (i in 1:nrow(MMF)) {
       if (MMF[i, 2] <= MAF) {
        qefm[i] <- 0.2*MAF
        LIHflo[i] <- 1 #i denotes a low flow month
        } else {
         qefm[i] <- 0.4*MAF
         LIHflo[i] <- 3 #i denotes a high flow month
      }
    } 
  } 
     else if (i_mvef==5) {                 #--------------- Q90-Q50 (2014)
      for (i in 1:nrow(MMF)) {
       if (MMF[i, 2] <= MAF) {
        qefm[i] <-q90[[1]]
        LIHflo[i] <- 1 #i denotes a low flow month
        } else {
         qefm[i] <- q50[[1]]
         LIHflo[i] <- 3 #i denotes a high flow month
      }
    }
  }
} else { #case 3
  #---------------- eflow proportional to the incoming flow -----------
   for (i in 1:nrow(MMF)) {
    if (MMF[i,2] < MAF) {
      qefm[i] <- q90[[1]]
      } else {
       qefm[i] <- q50[[1]]
    }
  }
}
```

###### Conversion of monthly data to daily data
``` {r}
ndays <- c(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)
qefy <-vector("numeric", 365)
nsum <- 0
for (i in seq_along(ndays)){
  qefy[(nsum+1):(nsum+(ndays[i]))] <- rep(qefm[[i]], ndays[i])
  nsum <- ndays[i]+nsum
}

qef <- rep(qefy, ny) #GZ: Check for leap years
#SK: leap years is doable with lubridate package
#This gives a vector of 730 which makes sense, Guido's give 731, did he manually added the leap year? maybe with q90 at the end?
qef <- c(qef[1:32], qef[32], qef[33:730])
```

### Reservoir operation module ####
We kept the original code from Guido can also be done differently. The parameters are as follows;

* qhp: average discharge for the power production
* qcons: consumptive water use time series assumed as MAF
* qnconc: non-consumptive water use tume series mased on input dam power

```{r}
qhp <- power/damhei/9810             #(m3/s)
qcons <- rep(q90[[1,1]], nq)         #(m3/s) F
qncons <- rep (qhp,nq)               #(m3/s) 
qspill <- rep(0,nq)
qdown <- rep(0,nq)
qout <- rep(0, nq)
qnet <- rep(0, nq)
unmdem <- 0
unmdays <- 0
rvol <- rep(0, nq)                   # initialization
rvol[1] <- rvmax/2                   # initial reservoir volume 
dt <- 86400                          # seconds in a day
```

The dam operation 
```` {r}
for (i in 1:(nq-1)){
  qdown[i] <- qspill[i]+icons*qef[i]+(1-icons)*max(qef[i], qncons[i])
  qout[i] <- qdown[i]+icons*qcons[i]
  qnet[i] <- q_tt[["Monthly_flow"]][[i]]-qout[i]
  rvol[i+1] <- rvol[i]+qnet[i]*dt
  if (rvol[i]>rvmax){
    qspill[i+1] <- rvol[i]-rvmax
    rvol[i] <- rvmax
  } else if (rvol[i]<rvmin){
    unmdem <- unmdem+qcons[i]+qncons[i]      # total unmet demand (consumpt + non consumpt)
    unmdays <- unmdays+1                     # n. of days in which demand is unmet 
    qncons[i] <- 0
    qcons[i] <- 0
    rvol[i] <- rvmin
  }
}
```

### Plotting ####
```{R}
flow <- ggplot(q_tt,aes(Date, Monthly_flow)) +
  geom_line()+theme_bw()+ggtitle("Daily Discharge")
ggplotly(flow)
```






This R Markdown document is made interactive using Shiny. Unlike the more traditional workflow of creating static reports, you can now create documents that allow your readers to change the assumptions underlying your analysis and see the results immediately. 

To learn more, see [Interactive Documents](http://rmarkdown.rstudio.com/authoring_shiny.html).

## Inputs and Outputs

You can embed Shiny inputs and outputs in your document. Outputs are automatically updated whenever inputs change.  This demonstrates how a standard R plot can be made interactive by wrapping it in the Shiny `renderPlot` function. The `selectInput` and `sliderInput` functions create the input widgets used to drive the plot.

```{r eruptions, echo=FALSE}
inputPanel(
  selectInput("n_breaks", label = "Number of bins:",
              choices = c(10, 20, 35, 50), selected = 20),
  
  sliderInput("bw_adjust", label = "Bandwidth adjustment:",
              min = 0.2, max = 2, value = 1, step = 0.2)
)

renderPlot({
  hist(faithful$eruptions, probability = TRUE, breaks = as.numeric(input$n_breaks),
       xlab = "Duration (minutes)", main = "Geyser eruption duration")
  
  dens <- density(faithful$eruptions, adjust = input$bw_adjust)
  lines(dens, col = "blue")
})
```

## Embedded Application

It's also possible to embed an entire Shiny application within an R Markdown document using the `shinyAppDir` function. This example embeds a Shiny application located in another directory:

```{r tabsets, echo=FALSE}
shinyAppDir(
  system.file("examples/06_tabsets", package = "shiny"),
  options = list(
    width = "100%", height = 550
  )
)
```

Note the use of the `height` parameter to determine how much vertical space the embedded application should occupy.

You can also use the `shinyApp` function to define an application inline rather then in an external directory.

In all of R code chunks above the `echo = FALSE` attribute is used. This is to prevent the R code within the chunk from rendering in the document alongside the Shiny components.



